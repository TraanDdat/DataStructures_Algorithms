Ex:
    * 50      70 60 90 40 80 10 20 30
      pivot   i                    j
    Compare "pivot" to "i" (if i is greater than "pivot" --> stop i, if not --> move i, if j is less than "pivot" --> stop j, if not --> move j, and swap i and j)
    -->     50      30 60 90 40 80 10 20 70

    * 50      30 60 90 40 80 10 20 70
      pivot      i              j
    Compare "pivot" to "i" (if i is greater than "pivot" --> stop i, if not --> move i, if j is less than "pivot" --> stop j, if not --> move j, and swap i and j)
    -->     50      30 20 90 40 80 10 60 70

    * 50      30 20 90 40 80 10 60 70
      pivot         i        j
    Compare "pivot" to "i" (if i is greater than "pivot" --> stop i, if not --> move i, if j is less than "pivot" --> stop j, if not --> move j, and swap i and j)
    -->     50      30 20 10 40 80 90 60 70
    
    * 50      30 20 10 40 80 90 60 70
      pivot            i  j
    Compare "pivot" to "i" (if i is greater than "pivot" --> stop i, if not --> move i, if j is less than "pivot" --> stop j, if not --> move j, and swap i and j)
    -->     50      30 20 10 40 80 90 60 70
                             j  i
    After we checked all of elements --> Interchange "pivot" element with j element
    -->     40 30 20 10     50      80 90 60 70
                        partitioning
                        position

* Note:
    - The worst case: Using "Quick sort" with "Sorted List" ( If partitioning is on any end ) --> O(n^2)
    - The best case: If partitioning is in middle --> O(nlogn)
    - Avg cases time: O(nlogn)
    - In Quick sort, we select an element and find out the position for that element.